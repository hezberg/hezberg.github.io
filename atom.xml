<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mumbo jumbo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="hezberg.github.io/"/>
  <updated>2020-01-30T13:34:24.841Z</updated>
  <id>hezberg.github.io/</id>
  
  <author>
    <name>zeh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective C++ - Resource Management</title>
    <link href="hezberg.github.io/2020/effective-cpp-notes/"/>
    <id>hezberg.github.io/2020/effective-cpp-notes/</id>
    <published>2020-01-30T10:24:31.000Z</published>
    <updated>2020-01-30T13:34:24.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-Resource-Management"><a href="#3-Resource-Management" class="headerlink" title="3. Resource Management"></a>3. Resource Management</h2><h3 id="Item-13-Use-objects-to-manage-resources"><a href="#Item-13-Use-objects-to-manage-resources" class="headerlink" title="Item 13: Use objects to manage resources."></a>Item 13: Use objects to manage resources.</h3><ol><li><p>以工厂模式的获取方式作为切入点，强调在外层函数f内，获取指针是通过函数返回，没有明显的new操作，但是需要手动delete，而且需要人工保证f函数的每一个出口都需要写delete，增加了维护代码的复杂性，因为每个增加的函数出口都需要添加。</p></li><li><p>改进办法一：把资源放进对象内（RAII，Resource Acquisition is Initialization），便可以依赖”C++析构函数自动调用机制“确保资源被释放。<br> 这个办法有两个关键点：获得资源后<strong>立刻</strong>放进管理对象内:</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span>Invest<span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token function">createInvest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 不论是赋值还是初始化，都需要在获得的同时立刻被放进管理对象内。<br> 第二个关键点是：管理对象运用析构函数确保资源被释放。正常析构情况下没问题，但是如果资源释放的动作可能导致抛出异常，事情就会很棘手，但是参照<strong>Item 8</strong>就能避免发生。</p></li><li><p>auto_ptr的潜在问题：根据<a href="https://en.cppreference.com/w/cpp/memory/auto_ptr" target="_blank" rel="noopener">auto_ptr的官方定义</a>：</p><blockquote><p><code>auto_ptr</code> is a smart pointer that manages an object obtained via new expression and deletes that object when <code>auto_ptr</code> itself is destroyed. </p></blockquote><p><code>auto_ptr</code>被销毁时会自动删除它所指之物，所以一定要注意别让多个<code>auto_ptr</code>同时指向同一个对象,不然多次删除一个对象,造成“未定义行为”.<code>auto_ptr</code>有一个不同寻常的性质:<strong>若通过copy构造函数或copy assignment操作符复制它们,它们会变成null,而复制所得的指针将取得资源唯一拥有权.</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">{</span>    auto_ptr<span class="token operator">&lt;</span>Invest<span class="token operator">></span> <span class="token function">pInv1</span><span class="token punctuation">(</span><span class="token function">createInvest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    auto_ptr<span class="token operator">&lt;</span>Invest<span class="token operator">></span> <span class="token function">pInv2</span><span class="token punctuation">(</span>pInv1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pInv2指向对象,pInv1被设为null</span>    pInv1 <span class="token operator">=</span> pInv2<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// pInv1指向对象, pInv1被设为null</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为auto_ptr的这些诡异行为,意味auto_ptr并非管理动态分配资源的神兵利器.</p></li><li><p>auto_ptr的替代方案是:”引用计数型智慧指针”(reference-counting smart pointer, <code>RCSP</code>).RCSP提供类似垃圾回收(garbage collection, <code>GC</code>). 但是RCSP也有需要注意的地方,环状引用(cycles of references, 例如两个其实已经没被使用的对象彼此互指,因而好像还处在“被使用”状态).</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>Invest<span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token function">createInvest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Invest<span class="token operator">></span> <span class="token function">pInv2</span><span class="token punctuation">(</span>pInv1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pInv1和pInv2指向同一个对象</span>    pInv1 <span class="token operator">=</span> pInv2<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 同上</span> <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// pInv1和pInv2被销毁, 它们所指的对象也就被自动销毁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_ptr也就是一种RCSP. 上述是它和auto_ptr在复制行为上的不同.但是这条item并不是只针对shared_ptr,只是强调“以对象管理资源”的重要性. </p><p><code>auto_ptr</code>和<code>shared_ptr</code>两者的在其析构函数内部做<code>delete</code>而不是<code>delete[]</code>动作.那意味着在动态分配而得到的<code>array</code>身上不要使用<code>auto_ptr</code>和<code>shared_ptr</code>.尽管如此,但是这样写仍然能通过编译:</p><pre class="line-numbers language-cpp"><code class="language-cpp">auto_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">aps</span><span class="token punctuation">(</span><span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//馊主意,会用上错误的delete形式</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">spi</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//相同问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>批注1:<code>auto_ptr</code>在C11标准中已经是<code>deprecated</code>状态.</p><p>批注2: 类似于本例中使用的<code>createInvest()</code>返回的“未加工指针”(<code>raw pointer</code>)是资源泄露的一个重大隐患,即使使用<code>auto_ptr</code>和<code>shared_ptr</code>,也必须记得将他的返回值存储在智能指针对象内.更好的解决办法是针对<code>createInvest</code>接口进行修改,可参照<code>Item 18</code>.</p><h3 id="Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="Item 14: Think carefully about copying behavior in resource-managing classes."></a>Item 14: Think carefully about copying behavior in resource-managing classes.</h3><p>这条讲的是自己写<code>RAII Class</code>应该注意的地方,但是实际中很少需要自己手写<code>RAII Class</code>来管理资源,文中举例的<code>mutex</code>的<code>lock</code>也有了对应的标准库函数.</p><p>但是其中有两点,对底层资源祭出”引用计数法”中提到,<code>shared_ptr</code>的构造函数中给定<code>deleter</code>,可以控制当<code>shared_ptr</code>计数为0的时候需要做的事情.这个方法在其他场景也可以使用到.</p><p>第二点是<code>deep copy</code>深度拷贝的处理方法,也可以在其他场景中使用到.</p><p>总的来说,这条主要记住如果要自己写<code>RAII Class</code>,有哪四种主要的方法.更多的是把这四种方法当做启发性的通用解决方法,在遇到其他情况的时候能够举一反三.</p><h3 id="Item-15-Provide-access-to-raw-resources-in-resource-managing-classes"><a href="#Item-15-Provide-access-to-raw-resources-in-resource-managing-classes" class="headerlink" title="Item 15: Provide access to raw resources in resource-managing classes"></a>Item 15: Provide access to raw resources in resource-managing classes</h3><p><code>RAII</code>很美好,但是现状是仍然有很多情况必须要使用<code>raw resource</code>.某些情况下的接口需要的<code>raw pointer</code>,但是传一个<code>auto_ptr</code>或者<code>shared_ptr</code>的对象,就会编译出错.两种解决办法:</p><ol><li><p>显示转换<br>提供<code>get()</code>函数,返回智能指针内部的原始指针(的复件).</p></li><li><p>隐式转换</p><ol><li><p>几乎所有的智能指针,都重载了指针取值(<code>pointer dereferencing</code>)操作符<code>operator-&gt;</code>和<code>operator*</code>,他们允许隐式转换至底部原始指针:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Invest</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// investment集成体系的根类</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isTaxFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Invest<span class="token operator">*</span> <span class="token function">createInvest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// factory函数</span>shared_ptr<span class="token operator">&lt;</span>Invest<span class="token operator">></span> <span class="token function">pi1</span><span class="token punctuation">(</span><span class="token function">createInvest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> taxable1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>pil<span class="token operator">-</span><span class="token operator">></span><span class="token function">isTaxFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 经由operator->访问资源</span>auto_ptr<span class="token operator">&lt;</span>Invest<span class="token operator">></span> <span class="token function">pi2</span><span class="token punctuation">(</span><span class="token function">createInvest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> taxable2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pi2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTaxFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 经由operator*访问资源</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第二种隐式转换是有些人会觉得<code>get()</code>方法很麻烦,</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-Resource-Management&quot;&gt;&lt;a href=&quot;#3-Resource-Management&quot; class=&quot;headerlink&quot; title=&quot;3. Resource Management&quot;&gt;&lt;/a&gt;3. Resource Management
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="hezberg.github.io/tags/cpp/"/>
    
      <category term="RAII" scheme="hezberg.github.io/tags/RAII/"/>
    
  </entry>
  
</feed>
